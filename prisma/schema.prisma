// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

enum VoteType {
  UP
  DOWN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String?
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id                String   @id @default(cuid())
  sessionToken      String   @unique
  userId            String
  expires           DateTime
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                String         @id @default(cuid())
  createdAt         DateTime       @default(now())
  name              String?
  username          String?        @unique
  image             String?
  bio               String?
  email             String?        @unique
  emailVerified     DateTime?
  emailNotified     Boolean        @default(true)
  password          String?
  roles             String[]       @default(["user"])
  keychainId        String?        @unique
  keychain          KeyChain?      @relation(fields: [keychainId], references: [id])
  accounts          Account[]
  sessions          Session[]
  problems          Problem[]
  problemVote       ProblemVote[]
  solutions         Solution[]
  solutionVote      SolutionVote[]
  replies           Reply[]
  replyVote         ReplyVote[]
}

model KeyChain {
  id                String    @id @default(uuid())
  starKeys          Int       @default(0)
  circleKeys        Int       @default(1000)
  user              User?     
}

model Problem {
  id                String          @id @default(cuid())
  title             String
  content           String?
  tags              String?
  createdAt         DateTime        @default(now())
  prizeInCircleKeys Int
  prizeInStarKeys   Int
  updatedAt         DateTime        @updatedAt
  author            User            @relation(fields: [authorId], references: [id])
  authorId          String
  topSolution       String?
  open              Boolean         @default(true)
  problemUpdate     ProblemUpdate[]
  solutions         Solution[] 
  votes             ProblemVote[]
  voteSum           Int             @default(0)
}

model ProblemVote {
  user              User        @relation(fields: [userId], references: [id])
  userId            String
  problem           Problem     @relation(fields: [problemId], references: [id], onDelete: Cascade)
  problemId         String
  type              VoteType

  @@id([userId, problemId])
}

model ProblemUpdate {
  id                String    @id @default(cuid())
  content           String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  circleKeysAdded   Int
  starKeysAdded     Int
  problem           Problem   @relation(fields: [problemId], references: [id])
  problemId         String
}

model Solution {
  id                String          @id @default(cuid())
  content           String
  createdAt         DateTime        @default(now())
  author            User            @relation(fields: [authorId], references: [id])
  authorId          String
  problem           Problem         @relation(fields: [problemId], references: [id], onDelete: Cascade)
  problemId         String
  solutionUpdate    SolutionUpdate[]
  votes             SolutionVote[]
  voteSum           Int             @default(0)
  solutionId        String?
  replies           Reply[]
}

model SolutionVote {
  user              User      @relation(fields: [userId], references: [id])
  userId            String
  solution          Solution  @relation(fields: [solutionId], references: [id], onDelete: Cascade)
  solutionId        String
  type              VoteType

  @@id([userId, solutionId])
}

model SolutionUpdate {
  id                String    @id @default(cuid())
  content           String
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  solution          Solution  @relation(fields: [solutionId], references: [id])
  solutionId        String
}

model Reply {
  id                String          @id @default(cuid())
  content           String
  createdAt         DateTime        @default(now())
  solutionId        String?
  authorId          String
  parentReplyId     String?
  solution          Solution?       @relation(fields: [solutionId], references: [id])
  user              User            @relation(fields: [authorId], references: [id])
  parentReply       Reply?          @relation("ReplyToReply", fields: [parentReplyId], references: [id])
  childReplies      Reply[]         @relation("ReplyToReply")
  votes             ReplyVote[]
  voteSum           Int             @default(0)
}

model ReplyVote {
  type              VoteType
  userId            String
  replyId           String
  user              User            @relation(fields: [userId], references: [id])
  reply             Reply           @relation(fields: [replyId], references: [id])

  @@unique([userId, replyId]) // Ensures a user can only vote once per reply
}
